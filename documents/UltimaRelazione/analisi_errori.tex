\section{Autocritica}
La principale causa che ha portato alle differenze viste ed analizzate in precedenza è sicuramente la nostra abitudine al paradigma di programmazione e al modello di concorrenza "Java". Il ragionamento sviluppato era ovviamente worst-case driven.  Nelle nostre ipotesi il caso pessimo era il più catastrofistico possibile senza assunzioni di controllo sulle entità attive. Presa coscienza della soluzione suggerita al colloquio ci rendiamo conto che usando il modello di concorrenza in Ada lo scenario worst-case risulta essere molto più blando rispetto a quello pensato in fase di progettazione. Dopo aver valutato la bozza di soluzione attesa sicuramente il worst-case reale si riduceva al risveglio di tutti le entità attive nel sistema nello stesso istante, fatto che nell'ambiente di esecuzione di Ada non influisce con ritardi significativi (infatti i tempi utilizzati nella simulazione sono millisecondi, che rispetto ad una granularità al miliardesimo di secondo dell’ambiente di esecuzione portano a ritardi non visibili da un osservatore). All'inizio della fase di progettazione si era ipotizzato di affidarsi ad un tempo di riferimento assoluto. Dopo aver riscontrato i primi potenziali problemi nel sistema concorrente locale ( valutazione del nostro worst-case ) e costruiti possibili scenari distribuiti abbiamo riscontrato dal nostro punto di vista l'incontrollabilità del sistema se gestito con tempi assoluti. La soluzione progettata quindi utilizza tempi relativi, gestibili completamente da noi e genera  una simulazione completamente riproducibile e controllabile, anche con i delay e i problemi connessi alla rete. La base di tutti questi ragionamenti, che ci ha portato a commettere errori di valutazione che si sono poi propagati a cascata, è sicuramente l'assunzione di un worst-case che alla luce di quanto visto durante il colloquio è ben distante dalla realtà, in quanto non riproducibile nell'ambiente di esecuzione scelto. L'idea della nostra progettazione comunque era di mantenersi volutamente distanti dal linguaggio (e dall'ambiente scelto) per progettare il sistema e quindi si è arrivati a una reingegnerizzazione di strutture e meccanismi già presenti poi nel contesto di esecuzione. La decisione di riprogettare alcuni meccanismi è dovuta quasi certamente al pensiero Java oriented che abbiamo come bagaglio culturale. Inoltre certamente l’utilizzo dei tempi relativi gestiti a codice è stata influenzata dalla scarsa padronanza del paradigma di programmazione Ada. Probabilmente questo utilizzo di tempi relativi ha compromesso la semplicità del prodotto finale anche se riteniamo che il funzionamento sia corretto e verificabile.\\
Diciamo quindi che la scelta del livello di non determinismo può avere influenzato, al pari della scelta di una progettazione totalmente 'language-indipendent', la direzione presa in fase di progettazione. Ci rendiamo conto che in una soluzione come quella suggerita i ritardi di rete avrebbero potuto essere 'mappati' su ritardi esistenti nella realtà. Ma questo non è stato un pensiero fatto in fase di analisi. Non si voleva progettare cercando di giustificare o associare il non-determinismo intrinseco dato dalla rete a un non-determinismo reale. Abbiamo voluto invece raggiungere il massimo determinismo possibile per poi aggiungere eventualmente in un secondo momento delle componenti che permettessero di fornire un fattore "random" alla gara.\\
Una ulteriore scelta che ci ha portato a considerare scenari worst-case peggiori di quelli verificabili è stata di avere entità box intelligenti e in seguito di distribuire tali componenti. Nella nostra concezione di box come agente intelligente già a livello di simulazione locale avrebbe potuto (entrando in concorrenza con gli altri box e con i task dei piloti) portare a ritardi significativi nell'esecuzione, inficiando il sistema visto nel colloquio. Tutto questo sarebbe poi stato amplificato in fase di distribuzione della componente. Sicuramente avendo pensato a dei box come entità reattive, non dotate quindi di una intelligenza artificiale, la soluzione attesa sarebbe stata di più facile progettazione e implementazione.\\
La presentazione dei dati sarebbe potuta essere essere più fedele alla realtà se si fosse deciso di rielaborare lato 'view' i dati forniti dal 'model', simulando quindi lo scorrimento del tempo reale. Questa opzione è stata tralascia in quanto è stata ritenuta legata a fattori puramente 'estetici', senza i quali non sarebbe stata compromessa la correttezza del simulatore. Inoltre avrebbe introdotto alcuni problemi nell'interazione utente-simulazione. Per citare un esempio, se l'utente decidesse di far rientrare un concorrente ai box in un istante t della simulazione, filtrando i dati per presentarli in maniera realistica l'evento sarebbe giunto al simulatore in un momento successivo della gara.\\
Concludendo si può aggiungere una considerazione relativa alla complessità del progetto: ci si rende conto che la soluzione diverge ampiamente da quella vista al colloquio. Riconosciamo anche che con un minimo di assunzioni iniziali differenti avremmo potuto approdare ad una soluzione considerata apprezzabile. In linea di principio però non riteniamo che con le giuste premesse saremmo giunti alla soluzione suggerita. Nella sua semplicità, tale soluzione racchiude un'insieme di considerazioni che, senza un'adeguata esperienza, possono risultare di realizzazione più complessa di quanto sembri. Con questo non vogliamo dire che nel corso non siano state affrontate le tematiche adatte a risolvere determinate problematiche. Forse tuttavia una maggiore esperienza nonchè dimestichezza con alcune tecnologie ci avrebbe aiutato.