\section{La nostra analisi del problema}
\subsection{Definizione obbiettivo del simulatore}
Durante la fase iniziale del progetto, si è pensato a cosa esattamente si volesse ottenere dal prototipo del simulatore. Si è posto come requisito primario del prodotto da sviluppare la massima (per quanto possibile) predicibilità. Si è pianificato quindi di istanziare la prima fase dello studio della soluzione a progettare un simulatore che potesse produrre risultati deterministici, in pratica: una funzione. Si è deciso di dedicare ad una seconda fase dello studio l’introduzione di elementi che conferissero un certo livello di non determinismo alla simulazione. Questo per due motivi:
\begin{itemize}
               \item una volta sviluppato il sistema in modo tale che fosse totalmente predicibile (o in cui comunque gli elementi di non predicibilità fossero controllabili senza assunzioni troppo forti), sarebbe risultato meno complesso verificarne la correttezza. Dopo questo passo sarebbe stato possibile introdurre delle componenti per dare più realismo (fattori che influenzino la gara in modo stocastico)
                \item in secondo luogo si è pensato che l’utilizzatore del simulatore avrebbe potuto desiderare un sistema che, qualora richiesto e per quanto possibile, producesse output predicibile (esempio: data una configurazione di auto e una pista, l’ordine di arrivo e i tempi devono essere uguali per qualunque esecuzione)
\end{itemize}
\subsection{Studio delle entità di sistema}
si è scelto di seguire la strada più intuitiva in termini di mappabilità fra sistema simulato e sistema reale assumendo che la concorrenza dei thread in un sistema potesse simulare la concorrenza dei piloti nella realtà. Inoltre fissando un circuito come entità passiva ad accesso multiplo si sarebbe rispecchiato il comportamento reale dei piloti nel momento in cui provano ad attraversare un tratto. Allo stesso modo si è ipotizzato di poter, in un secondo momento, distribuire i box (la comunicazione radio fra box e concorrenti poteva essere vista come la comunicazione di rete) per poi infine progettare delle TV remote da cui fosse possibile assistere alla gara.
Abbiamo pensato al concetto di task/thread nella maniera più language-independent possibile, senza pensare alle primitive presenti in un preciso linguaggio di programmazione. Così facendo non si sono fatte assunzioni sull'ambiente di esecuzione arrivando a progettare un sistema implementabile in ogni linguaggio che offrisse le funzionalità di multithreading.
\subsection{Analisi dei problemi legati a concorrenza e distribuzione}
\subsubsection{Il determinismo innanzitutto}
Abbiamo iniziato a pensare al problema in un'ottica Ada-oriented, ovvero prendendo in considerazione la possibilità di portare avanti l’idea sfruttando le sospensioni dei thread, assumendo di poter adottare appunto le primitive di ADA a tale scopo. Pensammo di sfruttare la funzionalità di delay relativi (primitiva delay) per poter simulare il tempo di attraversamento che un concorrente richiede per un tratto. Tale soluzione però si è rivelata non praticabile in quanto la sospensione relativa nel nostro caso sarebbe stata influenzata dai prerilasci (ipotizzando che ogni auto eseguisse un loop per l’attraversamento sequenziale dei tratti della pista). Dopo questa prima bozza di soluzione abbiamo quindi pensato di affrontare il problema secondo un ottica di gestione delle situazioni di prerilasci che non compromettessero il buon andamento della simulazione. Si è quindi iniziato a ragionare in un’ottica worst-case-drivern.
            Volendo seguire la linea del 'massimo determinismo possibile', i ritardi non controllabili causati dalla comunicazione remota fra componenti non avrebbero favorito il raggiungimento di tale scopo se sul nodo centrale la simulazione fosse stata governata da un orologio assoluto. Non conoscendo a fondo i meccanismi offerti da Ada abbiamo anche ipotizzato a come si potesse risolvere il problema in altri linguaggi.
            (La soluzione proposta durante il colloquio prevedeva l’utilizzo della sospensione assoluta. Nella progettazione portata avanti questa opzione non ha mai preso campo in quanto )
            Il nostro pensiero però è fortemente orientato alla filosofia Java dove il modello di concorrenza impedisce un controllo completo dello scheduling dei thread.
            Forti di questo ragionamento abbiamo approcciato il problema (sempre senza perdere di vista il determinismo da noi richiesto)  ipottizzando un worst case molto simile a quello che si sarebbe potuto verificare nell’ambiente di esecuzione di altri linguaggi (Java su tutti) molto meno dotati dal punto di vista delle funzionalità offerte.
            Non vi è stata alcuna assunzione sulla potenza del calcolatore o sul numero di istruzioni macchina legate ad uno statement nel codice. E’ sembrato che assunzioni del genere non fossero adatte alla modellazione di scenari generici.
\subsubsection{Distribuzione e worst-case}
In una soluzione come quella suggerita durante il colloquio le problematiche di distribuzione vanno trattate insieme a quelle di concorrenza.
Nel nostro caso, invece, abbiamo cercato prima di formulare una soluzione che producesse una simulazione temporalmente coerente e completamente prevedibile in modo indipendente anche dalle scelte di distribuzione. La distribuzione è diventata quindi un motivo di discussione per completare gli scenari worst case in fase di analisi e una problematica da discutere in dettaglio in una seconda fase della progettazione. Come già accennato, i ritardi di rete non sono una caratteristica su cui è possibile avere gran controllo.
\subsection{Studio della soluzione}
 Studio di una soluzione che non potesse essere corrotta o ostacolata dal linguaggio e che rimanesse temporalmente coerente anche con la successiva distribuzione di alcune componenti.\\\\
La soluzione è stata, come già detto, pensata per poter essere implementata in modo del tutto platform e language indepentent. L’utilizzo di flussi di tempo relativi per ogni entità concorrente ha permesso di poter astrarre completamente dall’ambiente sul quale il sistema sarebbe stato eseguito nonchè dalla presenza o meno di determinati strumenti nel linguaggio utilizzato.
La differenza fra progettare una soluzione basata su un orologio di sistema e una basata su un’insieme di orologi relativi come la nostra è molto semplice: la prima sarebbe stata implementabile con sforzo relativamente basso con linguaggi adatti (le nostre conoscenze ci portano a pensare adesso penseremo ad ADA). Implementarla con un linguaggio tipo Java avrebbe richiesto uno sforzo ben più alto. Non tanto per avere una specie di timer che permettesse di ragionare sui tempi di sistema, quanto più per riuscire a dare un controllo ai thread concorrenti. Le specifiche relative alla gestione del multitasking nella JVM di Java non sono date poichè, volendo essere un linguaggio portabile, esse sono strettamente correlate al sistema operativo sottostante. Per scelta progettuale quindi java non offre nessuna garanzia su ordinamento e scheduling dei processi.
La seconda ha richiesto di progettare delle strutture dati (quali code ordinate sui tempi di arrivo) per permettere di applicare un controllo sui thread qualora non fosse stato possibile a livello di linguaggio. La soluzione ha chiaramente richiesto uno sforzo maggiore di quella suggerita in corso di colloquio, ma di sicuro sarebbe stata utilizzabile a prescindere dalla tecnologia e dal sistema dato.
Da quanto abbiamo evinto dal colloquio, inoltre, la soluzione consigliata si basava anche su assunzioni dipendenti dall’architettura del sistema, dal numero di istruzioni macchina corrispondendi in media ad ogni statement di codice eccetera. La soluzione che abbiamo adottato non voleva essere dipendente da tale assunzione. Si è pensato che la complessità del sistema avrebbe potuto crescere indiscriminatamente (per esempio implementanto un’intelligenza artificiale a livello di pilota più elaborata) senza dover intaccare la correttezza temporale del simulatore.
A prescindere da ciò, l’idea iniziale non voleva essere quella di tenere in considerazione caratteristiche di così basso livello per ragionare sulla soluzione.
\subsection{Progettazione dell'architettura}
\begin{itemize}
\item Dopo aver studiato la soluzione adatta a venire incontro alle esigenze esplicate in precedenza, si è passati alla progettazione dell’architettura del sistema. Si è cercato nella prima fase di concepire il sistema e le sue componenti non considerando l’esistenza di componenti distribuite. La soluzione presentata permetteva infatti di non preoccuparsi delle problematiche di rete per garantire la correttezza temporale del simulatore.
\item In un secondo momento, con l’architettura del sistema sotto mano, si è deciso quali componenti sarebbe stato desiderabile che fossero distribuite. A questo punto, attuare la separazione remota delle entità sarebbe stato compito di facile attuazione. Si decise di prendere in considerazione l’ipotesi di un middleware che fornisse un protocollo di comunicazione adatto a governare la maggior parte dei problemi dovuti alla presenza della rete in modo da garantire il corretto funzionamento della competizione anche con la distribuzione in mezzo.
            Le scelte furono finalizzate a fornire maggior realismo alla soluzione (box distribuiti per problemi radio, tv perchè naturalmente dislocate in giro) ed eventualmente fornire maggiore efficienza (IA dislocata in nodi separati per scalare con l'aumento di complessità della stessa) .Come ultima motivazione distribuire un single point of failure in più nodi in modo da rendere più robusta l'esecuzione della simulazione.
\end{itemize}