\section{La nostra analisi del problema}
\subsection{Definizione obbiettivo del simulatore}
Durante la fase iniziale del progetto, si è pensato a cosa esattamente si volesse ottenere dal prototipo del simulatore. Si è posto come requisito primario del prodotto da sviluppare la massima predicibilità, per quanto possibile. Si è pianificato quindi di utilizzare la prima fase dello studio della soluzione per progettare un simulatore che potesse produrre risultati deterministici. Quello che ci si aspettava era, in pratica, una funzione. Si è deciso di dedicare ad una seconda fase l'introduzione di elementi che conferissero un certo livello di non determinismo alla simulazione. Questo per due motivi:
\begin{itemize}
               \item una volta sviluppato il sistema in modo tale che fosse totalmente predicibile (o in cui comunque gli elementi di non predicibilità fossero controllabili senza assunzioni troppo forti), sarebbe risultato meno complesso verificarne la correttezza. Dopo questo passo sarebbe stato possibile introdurre delle componenti per dare più realismo (fattori che influenzino la gara in modo stocastico)
                \item in secondo luogo si è pensato che l’utilizzatore del simulatore avrebbe potuto desiderare un sistema che, qualora richiesto e per quanto possibile, producesse output predicibile (esempio: data una configurazione di auto e una pista, l’ordine di arrivo e i tempi devono essere uguali per qualunque esecuzione)
\end{itemize}
\subsection{Studio delle entità di sistema}
La strada più intuitiva per creare una relazione fra sistema simulato e realtà è quella di assumere che la concorrenza dei thread possa rappresentare le vicende dei piloti durante la gara.\\
Inoltre, fissando un circuito come entità passiva ad accesso multiplo si sarebbe riprodotto il comportamento reale dei piloti nel momento in cui provano ad attraversare un tratto.
Seguendo lo stesso ragionamento si è ipotizzato di poter, in un secondo momento, distribuire i box mappando la comunicazione radio fra box e concorrenti con la comunicazione di rete. Infine si è tenuto in considerazione di poter progettare delle TV remote da cui fosse possibile assistere alla gara.\\
Si è pensato al concetto di task/thread, o meglio, entità attiva, nella maniera più language-independent possibile, senza pensare alle primitive presenti in un preciso linguaggio di programmazione. Così facendo non si sono fatte assunzioni sull'ambiente di esecuzione. Questo ci ha permesso di arrivare a progettare un sistema implementabile in ogni linguaggio che offra le funzionalità di multithreading.
\subsection{Analisi dei problemi legati a concorrenza e distribuzione}
\subsubsection{Il determinismo prima di tutto}
Inizialmente si è studiata una soluzione che utilizzasse sospesioni relative per simulare l'attraversamento di tratti della pista. Successivamente si è valutato come l'idea avrebbe trovato una sua implementazione in un linguaggio come Ada.
Tale soluzione però si è rivelata non praticabile in quanto la sospensione relativa nel nostro caso sarebbe stata influenzata dai prerilasci (ipotizzando che ogni auto eseguisse un loop per l’attraversamento sequenziale dei tratti della pista). Ci sarebbe stato un accumulo di ritardi (drift) col passare delle iterazioni. Dopo questo approccio si è passati a pensare ad una soluzione che prevedesse l'utilizzo di sospensioni assolute. Parallelamente si è cominciato a pensare all'influenza che una eventuale distribuzione avrebbe potuto avere sul sistema iniziando a modellare i primi scenari worst-case.
Si è quindi iniziato a ragionare in un’ottica worst-case-driven.
Volendo seguire la linea del "massimo determinismo possibile", i ritardi non controllabili causati dalla comunicazione remota fra componenti non avrebbero favorito il raggiungimento di tale scopo se sul nodo centrale la simulazione fosse stata governata da un orologio assoluto. Non conoscendo a fondo i meccanismi offerti da Ada abbiamo anche ipotizzato a come si potesse risolvere il problema in altri linguaggi.
Il nostro pensiero però è fortemente orientato alla filosofia Java dove il modello di concorrenza impedisce un controllo completo dello scheduling dei thread.
Forti di questo ragionamento abbiamo approcciato il problema (sempre senza perdere di vista il determinismo da noi richiesto)  ipottizzando un worst case molto simile a quello che si sarebbe potuto verificare nell’ambiente di esecuzione di altri linguaggi (Java su tutti) molto meno dotati dal punto di vista delle funzionalità offerte.
Non vi è stata alcuna assunzione sulla potenza del calcolatore o sul numero di istruzioni macchina legate ad uno statement nel codice. E’ sembrato che assunzioni del genere non fossero adatte alla modellazione di scenari generici.
\subsubsection{Distribuzione e worst-case}
In una soluzione come quella suggerita durante il colloquio le problematiche di distribuzione vanno trattate insieme a quelle di concorrenza.
Nel nostro caso, invece, abbiamo cercato prima di formulare una soluzione che producesse una simulazione temporalmente coerente e completamente prevedibile in modo indipendente anche dalle scelte di distribuzione. La distribuzione è diventata quindi un motivo di discussione per completare gli scenari worst case in fase di analisi e una problematica da discutere in dettaglio in una seconda fase della progettazione. Come già accennato, i ritardi di rete non sono una caratteristica su cui è possibile avere gran controllo.
\subsection{Studio della soluzione}
La soluzione è stata, come già detto, pensata per poter essere implementata in modo del tutto platform e language indepentent. L’utilizzo di flussi di tempo relativi per ogni entità concorrente ha permesso di poter astrarre completamente dall’ambiente sul quale il sistema sarebbe stato eseguito nonchè dalla presenza o meno di determinati strumenti nel linguaggio utilizzato.
La differenza fra progettare una soluzione basata su un orologio di sistema e una basata su un'insieme di orologi relativi come la nostra è molto semplice: la prima sarebbe stata implementabile con sforzo relativamente basso con linguaggi adatti (adesso penseremo ad Ada). Implementarla con un linguaggio tipo Java avrebbe richiesto uno sforzo ben più alto. Non tanto per avere una specie di timer che permettesse di ragionare sui tempi di sistema, quanto più per riuscire a dare un controllo ai thread concorrenti. Le specifiche relative alla gestione del multitasking nella JVM di Java non sono date poichè, volendo essere un linguaggio portabile, esse sono strettamente correlate al sistema operativo sottostante. Per scelta progettuale quindi java non offre nessuna garanzia su ordinamento e scheduling dei processi.
La seconda ha richiesto di progettare delle strutture dati (quali code ordinate sui tempi di arrivo) per permettere di applicare un controllo sui thread qualora non fosse stato possibile a livello di linguaggio. La soluzione ha chiaramente richiesto uno sforzo maggiore di quella suggerita in corso di colloquio, ma di sicuro sarebbe stata utilizzabile a prescindere dalla tecnologia e dal sistema dato.
Da quanto abbiamo evinto dal colloquio, inoltre, la soluzione consigliata si basava anche su assunzioni dipendenti dall’architettura del sistema, dal numero di istruzioni macchina corrispondendi in media ad ogni statement di codice eccetera. La soluzione che abbiamo adottato non voleva essere dipendente da tale assunzione. Si è pensato che la complessità del sistema avrebbe potuto crescere indiscriminatamente (per esempio implementanto un’intelligenza artificiale a livello di pilota più elaborata) senza dover intaccare la correttezza temporale del simulatore.
%A prescindere da ciò, l’idea iniziale non voleva essere quella di tenere in considerazione caratteristiche di così basso livello per ragionare sulla soluzione.
\subsection{Progettazione dell'architettura}
Dopo aver studiato la soluzione adatta a venire incontro alle esigenze esplicate in precedenza, si è passati alla progettazione dell’architettura del sistema. Si è cercato nella prima fase di concepire il sistema e le sue componenti non considerando l’esistenza di entità distribuite. La soluzione presentata permetteva infatti di non preoccuparsi delle problematiche di rete per garantire la correttezza temporale del simulatore.\\
In un secondo momento, con l’architettura del sistema sotto mano, si è deciso quali componenti sarebbe stato desiderabile che fossero distribuite. A questo punto, attuare la separazione remota delle entità sarebbe stato compito di facile attuazione. Si decise di prendere in considerazione l’ipotesi di un middleware che fornisse un protocollo di comunicazione adatto a governare la maggior parte dei problemi dovuti alla presenza della rete in modo da garantire il corretto funzionamento della competizione anche con la distribuzione in mezzo.
Le scelte furono finalizzate a fornire maggior realismo alla soluzione (box distribuiti per problemi radio, tv perchè naturalmente dislocate in giro) ed eventualmente fornire maggiore efficienza (IA dislocata in nodi separati per scalare con l'aumento di complessità della stessa) .Come ultima motivazione distribuire il caricodi lavoro in più nodi in modo da alleggerire il server ospitante la competizione.